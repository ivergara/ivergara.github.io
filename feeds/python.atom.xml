<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>On data, programming, and technology - Python</title><link href="https://ivergara.github.io/" rel="alternate"></link><link href="https://ivergara.github.io/feeds/python.atom.xml" rel="self"></link><id>https://ivergara.github.io/</id><updated>2018-11-28T10:20:00+01:00</updated><entry><title>Having fun with dataclasses and abstract baseÂ classes</title><link href="https://ivergara.github.io/ABC-and-dataclasses.html" rel="alternate"></link><published>2018-11-28T10:20:00+01:00</published><updated>2018-11-28T10:20:00+01:00</updated><author><name>Ignacio Vergara Kausel</name></author><id>tag:ivergara.github.io,2018-11-28:/ABC-and-dataclasses.html</id><summary type="html"></summary><content type="html">&lt;p&gt;Python is well known for the little boilerplate needed to get something to work. But even Python can get a bit cumbersome when a whole bunch of relatively trivial methods have to be defined to get the desired behavior of a class.
In this article we&amp;#8217;re going to explore how to combine &lt;a href="https://docs.python.org/3/library/dataclasses.html"&gt;&lt;code&gt;dataclases&lt;/code&gt;&lt;/a&gt; with the &lt;a href="https://docs.python.org/3.7/library/abc.html"&gt;&lt;code&gt;abc&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://docs.python.org/3.7/library/collections.abc.html"&gt;&lt;code&gt;collections.abc&lt;/code&gt;&lt;/a&gt; modules of the standard library in Python. I&amp;#8217;ll assume that you know/understand what &lt;code&gt;abc&lt;/code&gt;, &lt;code&gt;collections.abc&lt;/code&gt; and &lt;code&gt;dataclases&lt;/code&gt;. With the last two one could get a lot of behavior for &lt;strong&gt;free&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;If you don&amp;#8217;t know about abstract base classes then I strongly recommend to check articles like &lt;a href="http://blog.thedigitalcatonline.com/blog/2016/04/03/abstract-base-classes-in-python/"&gt;this&lt;/a&gt; and &lt;a href="http://stupidpythonideas.blogspot.com/2015/07/creating-new-sequence-type-is-easy.html"&gt;this&lt;/a&gt;, for &lt;code&gt;abc&lt;/code&gt;, and &lt;code&gt;abc.collections&lt;/code&gt;, respectivelly. Likewise, if you don&amp;#8217;t know why &lt;code&gt;dataclasses&lt;/code&gt; are interesting and about their advantages, you should check &lt;a href="https://realpython.com/python-data-classes/"&gt;this&lt;/a&gt; other article. Or if you prefer some more visual guide check &lt;a href="https://www.youtube.com/watch?v=epKegvx_Jws"&gt;this&lt;/a&gt; talk. Take the time to learn these tools, it&amp;#8217;ll be worth it. Personally, since I discovered the &lt;code&gt;abc&lt;/code&gt; and &lt;code&gt;collections.abc&lt;/code&gt; modules, I&amp;#8217;ve been trying to use them every time I&amp;nbsp;can. &lt;/p&gt;
&lt;p&gt;When I saw the inclusion of the &lt;code&gt;dataclass&lt;/code&gt; module in the standard library of Python 3.7, I told myself I wanted to use it. Being able to reduce even more the boilerplate in Python seemed like a great idea. Of course I could have already been using &lt;a href="https://www.attrs.org/"&gt;&lt;code&gt;attrs&lt;/code&gt;&lt;/a&gt; for basically the same effect, but when I tried it it didn&amp;#8217;t feel natural. That was most likely due to a lack of experience on my&amp;nbsp;part.&lt;/p&gt;
&lt;p&gt;Thus, it&amp;#8217;s very obvious that I&amp;#8217;d end up mixing abstract classes, abstract collections, and dataclasses eventually at some point. Unfortunatelly, I haven&amp;#8217;t taken the time to refactor the code at work to this effect. To ammend that, I decided to explore the combination of &lt;code&gt;abc+dataclasses&lt;/code&gt; and &lt;code&gt;abc.collections+dataclasses&lt;/code&gt; with a toy example to see how straightforward, or not, the combination works. And since I didn&amp;#8217;t find any article mixing these two concepts (not that I looked too much around), I decided to write about&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;Now, getting our fingers dirty. First let&amp;#8217;s use &lt;code&gt;pipenv&lt;/code&gt; to create an environment (as you should do to keep some environment hygene). It can feel slightly an overkill to do so, but I find it easier than trying to create a virtual environment from scratch. So, we initialize a Python 3.7 environment as follows &lt;code&gt;pipenv --python 3.7&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;To guide this experiment, we&amp;#8217;ll write a simple test. You could for sure skip this and manually play with the code in the &lt;span class="caps"&gt;REPL&lt;/span&gt; of choice, which I&amp;#8217;d recommend in any case in this case to freely explore and discover your use case, but having tests makes the process easier. Install &lt;code&gt;pytest&lt;/code&gt; to run the tests by executing &lt;code&gt;pipenv install pytest&lt;/code&gt;. Note that I&amp;#8217;m not using a separate &lt;code&gt;dev&lt;/code&gt; environment for this, as this is just an experimentation environment. Now, we can activate the virtual environment by using &lt;code&gt;pipenv shell&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The simplest test I can come up with, is that the abstract class &lt;code&gt;Base&lt;/code&gt; should raise a &lt;code&gt;TypeError&lt;/code&gt; exception if you try to instantiate it&amp;nbsp;directly.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# test_demo.py&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;demo&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_abstract_base_class&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;pytest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;raises&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ne"&gt;TypeError&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Before executing &lt;code&gt;pytest&lt;/code&gt;, since it&amp;#8217;ll fail, we can quickly write an implementation based on &lt;code&gt;dataclasses&lt;/code&gt; and &lt;code&gt;abc&lt;/code&gt;. As such, the class is decorated with &lt;code&gt;@dataclass&lt;/code&gt; and inherits from &lt;code&gt;abc.ABC&lt;/code&gt;. Furthermore, it&amp;#8217;ll define one field &lt;code&gt;a&lt;/code&gt; of type &lt;code&gt;str&lt;/code&gt; with a &lt;code&gt;__post_init__&lt;/code&gt; and a &lt;code&gt;process&lt;/code&gt; method, the last one defined as&amp;nbsp;abstract.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# demo.py&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;abc&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;dataclasses&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;dataclass&lt;/span&gt;

&lt;span class="nd"&gt;@dataclass&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ABC&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__post_init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
      &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="nd"&gt;@abc.abstractmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So far so good. Since the &lt;code&gt;__post_init__&lt;/code&gt; method is not an abstract one, it&amp;#8217;ll be executed in each class that inherits from &lt;code&gt;Base&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now it&amp;#8217;s time to create a class that implements the abstract class. As it is described in the &lt;a href="https://docs.python.org/3/library/dataclasses.html#inheritance"&gt;reference&lt;/a&gt;, for inheritance in &lt;code&gt;dataclasses&lt;/code&gt; to work, both classes have to be decorated.
In this case, the implementation will define another field, &lt;code&gt;b&lt;/code&gt; of type &lt;code&gt;str&lt;/code&gt;, reimplement the &lt;code&gt;__post_init__&lt;/code&gt; method, and implement the abstract method &lt;code&gt;process&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# demo.py&lt;/span&gt;
&lt;span class="nd"&gt;@dataclass&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Implementation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__post_init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__post_init__&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;{self.a} {self.b}&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We&amp;#8217;re reimplementing the &lt;code&gt;__post_init__&lt;/code&gt; method just to show that we could cover more sophisticated use cases easily. This forces us to call &lt;code&gt;super().__post_init__()&lt;/code&gt; to get the post initialization of the base class. Now we can cover the behavior of this new class in a test as&amp;nbsp;follows.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# test_demo.py&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;demo&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Implementation&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_implementation&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;implemented_instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Implementation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Pythonic&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Musings&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;implemented_instance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;implemented_instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;PYTHONIC musings&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In this test, the first &lt;code&gt;assert&lt;/code&gt; is to make sure that the &lt;code&gt;Implemented&lt;/code&gt; class is really an instance of &lt;code&gt;Base&lt;/code&gt;. We could have just trusted Python, but since this article has an educational purpose, better to be explicit about our&amp;nbsp;expectations.&lt;/p&gt;
&lt;p&gt;One great advantage of dataclasses is that you&amp;#8217;re forced to do type annotation. So we can see what happens if we run a type checker like &lt;code&gt;mypy&lt;/code&gt; on it. Executing &lt;code&gt;pipenv install mypy&lt;/code&gt; and then &lt;code&gt;mypy .&lt;/code&gt; we get the&amp;nbsp;following&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;demo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Only&lt;/span&gt; &lt;span class="n"&gt;concrete&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;can&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;given&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Type[Base]&amp;quot;&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;expected&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Only one error! That&amp;#8217;s worse than what we&amp;#8217;d expected. Searching a bit, I found the following &lt;a href="https://github.com/python/mypy/issues/5374"&gt;issue&lt;/a&gt; discussing this situation. Otherwise all checks up fine, and we&amp;#8217;re not interested in &lt;code&gt;mypy&lt;/code&gt;&lt;span class="quo"&gt;&amp;#8216;&lt;/span&gt;s edge cases so we could ignore it, or silence it in case you&amp;#8217;re running &lt;code&gt;mypy&lt;/code&gt; as part of a &lt;span class="caps"&gt;CI&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;At last we reach now to combining &lt;code&gt;dataclasses&lt;/code&gt; and the &lt;code&gt;collections.abc&lt;/code&gt; module. This combination is great since both modules provide ways to reduce boilerplate while also making intent very clear. To keep it simple it&amp;#8217;ll be a straight container with a field &lt;code&gt;c&lt;/code&gt; of type &lt;code&gt;List&lt;/code&gt; and a custom method &lt;code&gt;capitalize&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# demo.py&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;collections.abc&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;typing&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;

&lt;span class="nd"&gt;@dataclass&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collections&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Container&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__contains__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;capitalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here we get the full power of combining two boilerplate reducing approaches.
This example, by no means shows all the potential of the &lt;code&gt;collections.abc&lt;/code&gt; since we chose the simplest collection possible. But it&amp;#8217;s only here to show that the combination with dataclasses works. I really recommend using the &lt;code&gt;collections.abs&lt;/code&gt; module as it will allows you to encapsulate a lot, and leads to a better&amp;nbsp;design.&lt;/p&gt;
&lt;p&gt;To test it, we can go with the following&amp;nbsp;code&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# test_demo.py&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;demo&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_derived&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Hi&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Bye&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Hi&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Bye&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;

    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capitalize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;HI&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;BYE&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The first assertion checks if our method works as intended. The second group of assertions, those inside the &lt;code&gt;for&lt;/code&gt; loop, has only a pedagogical objective since we are ultimately testing that the &lt;code&gt;collections.abs&lt;/code&gt; is working. Although sometimes, such a test is valid to comply with specification. Anyhow, will not go into epistemology of tests in here. Here again we see that the mix of &lt;code&gt;collections.abs&lt;/code&gt; and &lt;code&gt;dataclasses&lt;/code&gt; just&amp;nbsp;works.&lt;/p&gt;
&lt;p&gt;Our implementation of the &lt;code&gt;Derived&lt;/code&gt; class is very rough. As an exercise, try to turn the &lt;code&gt;capitalize&lt;/code&gt; method into a &lt;code&gt;classmethod&lt;/code&gt; that takes an instance of &lt;code&gt;Derived&lt;/code&gt; and returns an instance of the class with the capitalized elements. This would improve the ergonomics, since is not too coherent to return a &lt;code&gt;list&lt;/code&gt; in such an implicit way. Bonus points for proper type annotation! (Hint: check &lt;span class="caps"&gt;PEP&lt;/span&gt;&amp;nbsp;563.)&lt;/p&gt;
&lt;p&gt;With this we conclude the article. Not surprisingly, the &lt;code&gt;dataclasses&lt;/code&gt; module work extremely well together with &lt;code&gt;abc&lt;/code&gt; and &lt;code&gt;collections.abs&lt;/code&gt;. Certainly, after this exploration, I&amp;#8217;ll start using these combinations into the future and going through older code to make use of&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;Teaser: there is another thing in Python I enjoy using, the &amp;#8216;@property&amp;#8217; decorator. Personally, I also wonder how that mixes with &lt;code&gt;dataclasses&lt;/code&gt;, luckily someone already told their story &lt;a href="https://blog.florimondmanca.com/reconciling-dataclasses-and-properties-in-python"&gt;here&lt;/a&gt;. Spoiler alert, has a happy ending ;). Although while playing with it I&amp;#8217;ve found some edge cases where things stop working nicely. I hope to explore it in more detail and show some&amp;nbsp;alternative/solution.&lt;/p&gt;</content><category term="dataclasses"></category><category term="ABC"></category><category term="collections"></category><category term="boilerplate"></category><category term="Python 3.7"></category></entry></feed>